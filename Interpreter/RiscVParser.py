# Generated from RiscV.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0090")
        buf.write("\u00c7\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\3\2\7\2\32")
        buf.write("\n\2\f\2\16\2\35\13\2\3\2\3\2\7\2!\n\2\f\2\16\2$\13\2")
        buf.write("\3\2\3\2\3\3\3\3\3\4\3\4\3\4\7\4-\n\4\f\4\16\4\60\13\4")
        buf.write("\3\5\5\5\63\n\5\3\5\3\5\5\5\67\n\5\3\5\3\5\3\6\3\6\3\6")
        buf.write("\3\6\3\6\3\6\7\6A\n\6\f\6\16\6D\13\6\3\6\3\6\3\6\3\6\3")
        buf.write("\6\7\6K\n\6\f\6\16\6N\13\6\3\6\3\6\3\6\3\6\3\6\7\6U\n")
        buf.write("\6\f\6\16\6X\13\6\3\6\5\6[\n\6\3\7\3\7\3\7\7\7`\n\7\f")
        buf.write("\7\16\7c\13\7\3\b\5\bf\n\b\3\b\3\b\5\bj\n\b\3\b\3\b\3")
        buf.write("\t\3\t\3\n\3\n\3\13\3\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f")
        buf.write("\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f")
        buf.write("\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f")
        buf.write("\3\f\3\f\3\f\3\f\3\f\3\f\5\f\u00c5\n\f\3\f\2\2\r\2\4\6")
        buf.write("\b\n\f\16\20\22\24\26\2\17\4\2\u0084\u0084\u0086\u0086")
        buf.write("\3\2{}\3\2~\177\3\2\u0080\u0081\3\2\u008a\u008b\4\2PY")
        buf.write("\\c\3\2GL\3\2MO\3\2?C\3\2DF\3\2\65\66\3\2Z[\3\29>\2\u00d4")
        buf.write("\2\33\3\2\2\2\4\'\3\2\2\2\6)\3\2\2\2\b\62\3\2\2\2\nZ\3")
        buf.write("\2\2\2\f\\\3\2\2\2\16e\3\2\2\2\20m\3\2\2\2\22o\3\2\2\2")
        buf.write("\24q\3\2\2\2\26\u00c4\3\2\2\2\30\32\5\4\3\2\31\30\3\2")
        buf.write("\2\2\32\35\3\2\2\2\33\31\3\2\2\2\33\34\3\2\2\2\34\"\3")
        buf.write("\2\2\2\35\33\3\2\2\2\36!\5\6\4\2\37!\5\f\7\2 \36\3\2\2")
        buf.write("\2 \37\3\2\2\2!$\3\2\2\2\" \3\2\2\2\"#\3\2\2\2#%\3\2\2")
        buf.write("\2$\"\3\2\2\2%&\7\2\2\3&\3\3\2\2\2\'(\t\2\2\2(\5\3\2\2")
        buf.write("\2)*\7\3\2\2*.\5\4\3\2+-\5\b\5\2,+\3\2\2\2-\60\3\2\2\2")
        buf.write(".,\3\2\2\2./\3\2\2\2/\7\3\2\2\2\60.\3\2\2\2\61\63\7\u008e")
        buf.write("\2\2\62\61\3\2\2\2\62\63\3\2\2\2\63\64\3\2\2\2\64\66\b")
        buf.write("\5\1\2\65\67\5\n\6\2\66\65\3\2\2\2\66\67\3\2\2\2\678\3")
        buf.write("\2\2\289\5\4\3\29\t\3\2\2\2:;\7\u0082\2\2;[\7\u008c\2")
        buf.write("\2<=\t\3\2\2=B\7\u008c\2\2>?\7\7\2\2?A\7\u008c\2\2@>\3")
        buf.write("\2\2\2AD\3\2\2\2B@\3\2\2\2BC\3\2\2\2CE\3\2\2\2DB\3\2\2")
        buf.write("\2E[\b\6\1\2FG\t\4\2\2GL\7\u008d\2\2HI\7\7\2\2IK\7\u008d")
        buf.write("\2\2JH\3\2\2\2KN\3\2\2\2LJ\3\2\2\2LM\3\2\2\2MO\3\2\2\2")
        buf.write("NL\3\2\2\2O[\b\6\1\2PQ\t\5\2\2QV\7\u0083\2\2RS\7\7\2\2")
        buf.write("SU\7\u0083\2\2TR\3\2\2\2UX\3\2\2\2VT\3\2\2\2VW\3\2\2\2")
        buf.write("WY\3\2\2\2XV\3\2\2\2Y[\b\6\1\2Z:\3\2\2\2Z<\3\2\2\2ZF\3")
        buf.write("\2\2\2ZP\3\2\2\2[\13\3\2\2\2\\]\7\4\2\2]a\5\4\3\2^`\5")
        buf.write("\16\b\2_^\3\2\2\2`c\3\2\2\2a_\3\2\2\2ab\3\2\2\2b\r\3\2")
        buf.write("\2\2ca\3\2\2\2df\7\u008e\2\2ed\3\2\2\2ef\3\2\2\2fg\3\2")
        buf.write("\2\2gi\b\b\1\2hj\5\26\f\2ih\3\2\2\2ij\3\2\2\2jk\3\2\2")
        buf.write("\2kl\5\4\3\2l\17\3\2\2\2mn\t\6\2\2n\21\3\2\2\2op\7\u008c")
        buf.write("\2\2p\23\3\2\2\2qr\7\u008f\2\2r\25\3\2\2\2st\t\7\2\2t")
        buf.write("u\5\20\t\2uv\7\7\2\2vw\5\20\t\2wx\7\7\2\2xy\5\20\t\2y")
        buf.write("z\b\f\1\2z\u00c5\3\2\2\2{|\t\b\2\2|}\5\20\t\2}~\7\7\2")
        buf.write("\2~\177\5\20\t\2\177\u0080\7\7\2\2\u0080\u0081\5\22\n")
        buf.write("\2\u0081\u0082\b\f\1\2\u0082\u00c5\3\2\2\2\u0083\u0084")
        buf.write("\t\t\2\2\u0084\u0085\5\20\t\2\u0085\u0086\7\7\2\2\u0086")
        buf.write("\u0087\5\20\t\2\u0087\u0088\7\7\2\2\u0088\u0089\5\22\n")
        buf.write("\2\u0089\u008a\b\f\1\2\u008a\u00c5\3\2\2\2\u008b\u008c")
        buf.write("\t\n\2\2\u008c\u008d\5\20\t\2\u008d\u008e\7\7\2\2\u008e")
        buf.write("\u008f\5\22\n\2\u008f\u0090\7\b\2\2\u0090\u0091\5\20\t")
        buf.write("\2\u0091\u0092\7\t\2\2\u0092\u0093\b\f\1\2\u0093\u00c5")
        buf.write("\3\2\2\2\u0094\u0095\t\13\2\2\u0095\u0096\5\20\t\2\u0096")
        buf.write("\u0097\7\7\2\2\u0097\u0098\5\22\n\2\u0098\u0099\7\b\2")
        buf.write("\2\u0099\u009a\5\20\t\2\u009a\u009b\7\t\2\2\u009b\u009c")
        buf.write("\b\f\1\2\u009c\u00c5\3\2\2\2\u009d\u009e\t\f\2\2\u009e")
        buf.write("\u009f\5\20\t\2\u009f\u00a0\7\7\2\2\u00a0\u00a1\5\22\n")
        buf.write("\2\u00a1\u00a2\b\f\1\2\u00a2\u00c5\3\2\2\2\u00a3\u00a4")
        buf.write("\t\r\2\2\u00a4\u00c5\b\f\1\2\u00a5\u00a6\t\16\2\2\u00a6")
        buf.write("\u00a7\5\20\t\2\u00a7\u00a8\7\7\2\2\u00a8\u00a9\5\20\t")
        buf.write("\2\u00a9\u00aa\7\7\2\2\u00aa\u00ab\5\22\n\2\u00ab\u00ac")
        buf.write("\b\f\1\2\u00ac\u00c5\3\2\2\2\u00ad\u00ae\7\67\2\2\u00ae")
        buf.write("\u00af\5\20\t\2\u00af\u00b0\7\7\2\2\u00b0\u00b1\5\22\n")
        buf.write("\2\u00b1\u00b2\b\f\1\2\u00b2\u00c5\3\2\2\2\u00b3\u00b4")
        buf.write("\78\2\2\u00b4\u00b5\5\20\t\2\u00b5\u00b6\7\7\2\2\u00b6")
        buf.write("\u00b7\5\20\t\2\u00b7\u00b8\7\7\2\2\u00b8\u00b9\5\22\n")
        buf.write("\2\u00b9\u00ba\b\f\1\2\u00ba\u00c5\3\2\2\2\u00bb\u00bc")
        buf.write("\78\2\2\u00bc\u00bd\5\20\t\2\u00bd\u00be\7\7\2\2\u00be")
        buf.write("\u00bf\5\22\n\2\u00bf\u00c0\7\b\2\2\u00c0\u00c1\5\20\t")
        buf.write("\2\u00c1\u00c2\7\t\2\2\u00c2\u00c3\b\f\1\2\u00c3\u00c5")
        buf.write("\3\2\2\2\u00c4s\3\2\2\2\u00c4{\3\2\2\2\u00c4\u0083\3\2")
        buf.write("\2\2\u00c4\u008b\3\2\2\2\u00c4\u0094\3\2\2\2\u00c4\u009d")
        buf.write("\3\2\2\2\u00c4\u00a3\3\2\2\2\u00c4\u00a5\3\2\2\2\u00c4")
        buf.write("\u00ad\3\2\2\2\u00c4\u00b3\3\2\2\2\u00c4\u00bb\3\2\2\2")
        buf.write("\u00c5\27\3\2\2\2\20\33 \".\62\66BLVZaei\u00c4")
        return buf.getvalue()


class RiscVParser ( Parser ):

    grammarFileName = "RiscV.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'.data'", "'.text'", "'.config'", "'.eqv'", 
                     "','", "'('", "')'", "'pipelined'", "'forwarding'", 
                     "'delayed'", "'split'", "'unaligned'", "'overwritecode'", 
                     "'fullaccess'", "'on'", "'off'", "'exi'", "'exm'", 
                     "'exd'", "'exfp'", "'exfpm'", "'exfpd'", "'memory'", 
                     "'cache'", "'icache'", "'dcache'", "'size'", "'block'", 
                     "'way'", "'write'", "'cbwa'", "'wtnwa'", "'replace'", 
                     "'random'", "'lru'", "'fifo'", "'lfu'", "'adddev'", 
                     "'board'", "'arrows'", "'matrix'", "'keyboard'", "'screen'", 
                     "'bitbusy'", "'bitnewchar'", "'latency'", "'rows'", 
                     "'columns'", "'='", "'pattern'", "'lui'", "'auipc'", 
                     "'jal'", "'jalr'", "'beq'", "'bne'", "'blt'", "'bge'", 
                     "'bltu'", "'bgeu'", "'lb'", "'lh'", "'lw'", "'lbu'", 
                     "'lhu'", "'sb'", "'sh'", "'sw'", "'addi'", "'slti'", 
                     "'sltiu'", "'xori'", "'ori'", "'andi'", "'slli'", "'srli'", 
                     "'srai'", "'add'", "'sub'", "'sll'", "'slt'", "'sltu'", 
                     "'xor'", "'srl'", "'sra'", "'or'", "'and'", "'ecall'", 
                     "'ebreak'", "'mul'", "'mulh'", "'mulhsu'", "'mulhu'", 
                     "'div'", "'divu'", "'rem'", "'remu'", "'la'", "'nop'", 
                     "'li'", "'mv'", "'not'", "'neg'", "'seqz'", "'snez'", 
                     "'sltz'", "'sgtz'", "'beqz'", "'bnez'", "'blez'", "'bgez'", 
                     "'bltz'", "'bgtz'", "'bgt'", "'ble'", "'bgtu'", "'bleu'", 
                     "'j'", "'jr'", "'ret'", "'.word'", "'.half'", "'.byte'", 
                     "'.float'", "'.double'", "'.ascii'", "'.asciiz'", "'.space'" ]

    symbolicNames = [ "<INVALID>", "ZONADATOS", "ZONACODIGO", "ZONACONFIGURACION", 
                      "T_EQV", "COMA", "LPAREN", "RPAREN", "PIPELINED", 
                      "FORWARDING", "DELAYED", "SPLIT", "UNALIGNED", "OVERWRITECODE", 
                      "FULLACCESS", "ON", "OFF", "EXI", "EXM", "EXD", "EXFP", 
                      "EXFPM", "EXFPD", "MEMORY", "CACHE", "ICACHE", "DCACHE", 
                      "SIZE", "BLOCK", "WAY", "WRITE", "CBWA", "WTNWA", 
                      "REPLACE", "RANDOM", "LRU", "FIFO", "LFU", "ADDDEV", 
                      "BOARD", "ARROWS", "MATRIX", "KEYBOARD", "SCREEN", 
                      "BITBUSY", "BITNEWCHAR", "LATENCY", "FILAS", "COLS", 
                      "IGUAL", "PATTERN", "LUI", "AUIPC", "JAL", "JALR", 
                      "BEQ", "BNE", "BLT", "BGE", "BLTU", "BGEU", "LB", 
                      "LH", "LW", "LBU", "LHU", "SB", "SH", "SW", "ADDI", 
                      "SLTI", "SLTIU", "XORI", "ORI", "ANDI", "SLLI", "SRLI", 
                      "SRAI", "ADD", "SUB", "SLL", "SLT", "SLTU", "XOR", 
                      "SRL", "SRA", "OR", "AND", "ECALL", "EBREAK", "MUL", 
                      "MULH", "MULHSU", "MULHU", "DIV", "DIVU", "REM", "REMU", 
                      "LA", "NOP", "LI", "MV", "NOT", "NEG", "SEQZ", "SNEZ", 
                      "SLTZ", "SGTZ", "BEQZ", "BNEZ", "BLEZ", "BGEZ", "BLTZ", 
                      "BGTZ", "BGT", "BLE", "BGTU", "BLEU", "J", "JR", "RET", 
                      "T_WORD", "T_HALF", "T_BYTE", "T_FLOAT", "T_DOUBLE", 
                      "T_ASCII", "T_ASCIIZ", "T_SPACE", "CADENA", "COMENTARIO", 
                      "ESPACIOS", "NUEVALINEA", "PATRONBITS", "REG_FP", 
                      "REG_FP_NAME", "REG_INT", "REG_INT_NAME", "NUMERO_INT", 
                      "NUMERO_FP", "ETIQUETA", "IDENT", "CARACTERROR" ]

    RULE_prog = 0
    RULE_finlinea = 1
    RULE_bloquedatos = 2
    RULE_lineadatos = 3
    RULE_declaracion = 4
    RULE_bloquecodigo = 5
    RULE_lineacodigo = 6
    RULE_reg_int = 7
    RULE_inm_int = 8
    RULE_parEtiq = 9
    RULE_instruccion = 10

    ruleNames =  [ "prog", "finlinea", "bloquedatos", "lineadatos", "declaracion", 
                   "bloquecodigo", "lineacodigo", "reg_int", "inm_int", 
                   "parEtiq", "instruccion" ]

    EOF = Token.EOF
    ZONADATOS=1
    ZONACODIGO=2
    ZONACONFIGURACION=3
    T_EQV=4
    COMA=5
    LPAREN=6
    RPAREN=7
    PIPELINED=8
    FORWARDING=9
    DELAYED=10
    SPLIT=11
    UNALIGNED=12
    OVERWRITECODE=13
    FULLACCESS=14
    ON=15
    OFF=16
    EXI=17
    EXM=18
    EXD=19
    EXFP=20
    EXFPM=21
    EXFPD=22
    MEMORY=23
    CACHE=24
    ICACHE=25
    DCACHE=26
    SIZE=27
    BLOCK=28
    WAY=29
    WRITE=30
    CBWA=31
    WTNWA=32
    REPLACE=33
    RANDOM=34
    LRU=35
    FIFO=36
    LFU=37
    ADDDEV=38
    BOARD=39
    ARROWS=40
    MATRIX=41
    KEYBOARD=42
    SCREEN=43
    BITBUSY=44
    BITNEWCHAR=45
    LATENCY=46
    FILAS=47
    COLS=48
    IGUAL=49
    PATTERN=50
    LUI=51
    AUIPC=52
    JAL=53
    JALR=54
    BEQ=55
    BNE=56
    BLT=57
    BGE=58
    BLTU=59
    BGEU=60
    LB=61
    LH=62
    LW=63
    LBU=64
    LHU=65
    SB=66
    SH=67
    SW=68
    ADDI=69
    SLTI=70
    SLTIU=71
    XORI=72
    ORI=73
    ANDI=74
    SLLI=75
    SRLI=76
    SRAI=77
    ADD=78
    SUB=79
    SLL=80
    SLT=81
    SLTU=82
    XOR=83
    SRL=84
    SRA=85
    OR=86
    AND=87
    ECALL=88
    EBREAK=89
    MUL=90
    MULH=91
    MULHSU=92
    MULHU=93
    DIV=94
    DIVU=95
    REM=96
    REMU=97
    LA=98
    NOP=99
    LI=100
    MV=101
    NOT=102
    NEG=103
    SEQZ=104
    SNEZ=105
    SLTZ=106
    SGTZ=107
    BEQZ=108
    BNEZ=109
    BLEZ=110
    BGEZ=111
    BLTZ=112
    BGTZ=113
    BGT=114
    BLE=115
    BGTU=116
    BLEU=117
    J=118
    JR=119
    RET=120
    T_WORD=121
    T_HALF=122
    T_BYTE=123
    T_FLOAT=124
    T_DOUBLE=125
    T_ASCII=126
    T_ASCIIZ=127
    T_SPACE=128
    CADENA=129
    COMENTARIO=130
    ESPACIOS=131
    NUEVALINEA=132
    PATRONBITS=133
    REG_FP=134
    REG_FP_NAME=135
    REG_INT=136
    REG_INT_NAME=137
    NUMERO_INT=138
    NUMERO_FP=139
    ETIQUETA=140
    IDENT=141
    CARACTERROR=142

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RiscVParser.EOF, 0)

        def finlinea(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RiscVParser.FinlineaContext)
            else:
                return self.getTypedRuleContext(RiscVParser.FinlineaContext,i)


        def bloquedatos(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RiscVParser.BloquedatosContext)
            else:
                return self.getTypedRuleContext(RiscVParser.BloquedatosContext,i)


        def bloquecodigo(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RiscVParser.BloquecodigoContext)
            else:
                return self.getTypedRuleContext(RiscVParser.BloquecodigoContext,i)


        def getRuleIndex(self):
            return RiscVParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)




    def prog(self):

        localctx = RiscVParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 25
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RiscVParser.COMENTARIO or _la==RiscVParser.NUEVALINEA:
                self.state = 22
                self.finlinea()
                self.state = 27
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 32
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RiscVParser.ZONADATOS or _la==RiscVParser.ZONACODIGO:
                self.state = 30
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RiscVParser.ZONADATOS]:
                    self.state = 28
                    self.bloquedatos()
                    pass
                elif token in [RiscVParser.ZONACODIGO]:
                    self.state = 29
                    self.bloquecodigo()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 34
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 35
            self.match(RiscVParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FinlineaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUEVALINEA(self):
            return self.getToken(RiscVParser.NUEVALINEA, 0)

        def COMENTARIO(self):
            return self.getToken(RiscVParser.COMENTARIO, 0)

        def getRuleIndex(self):
            return RiscVParser.RULE_finlinea

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFinlinea" ):
                listener.enterFinlinea(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFinlinea" ):
                listener.exitFinlinea(self)




    def finlinea(self):

        localctx = RiscVParser.FinlineaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_finlinea)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37
            _la = self._input.LA(1)
            if not(_la==RiscVParser.COMENTARIO or _la==RiscVParser.NUEVALINEA):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BloquedatosContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZONADATOS(self):
            return self.getToken(RiscVParser.ZONADATOS, 0)

        def finlinea(self):
            return self.getTypedRuleContext(RiscVParser.FinlineaContext,0)


        def lineadatos(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RiscVParser.LineadatosContext)
            else:
                return self.getTypedRuleContext(RiscVParser.LineadatosContext,i)


        def getRuleIndex(self):
            return RiscVParser.RULE_bloquedatos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBloquedatos" ):
                listener.enterBloquedatos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBloquedatos" ):
                listener.exitBloquedatos(self)




    def bloquedatos(self):

        localctx = RiscVParser.BloquedatosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_bloquedatos)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 39
            self.match(RiscVParser.ZONADATOS)
            self.state = 40
            self.finlinea()
            self.state = 44
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 121)) & ~0x3f) == 0 and ((1 << (_la - 121)) & ((1 << (RiscVParser.T_WORD - 121)) | (1 << (RiscVParser.T_HALF - 121)) | (1 << (RiscVParser.T_BYTE - 121)) | (1 << (RiscVParser.T_FLOAT - 121)) | (1 << (RiscVParser.T_DOUBLE - 121)) | (1 << (RiscVParser.T_ASCII - 121)) | (1 << (RiscVParser.T_ASCIIZ - 121)) | (1 << (RiscVParser.T_SPACE - 121)) | (1 << (RiscVParser.COMENTARIO - 121)) | (1 << (RiscVParser.NUEVALINEA - 121)) | (1 << (RiscVParser.ETIQUETA - 121)))) != 0):
                self.state = 41
                self.lineadatos()
                self.state = 46
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineadatosContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._ETIQUETA = None # Token

        def finlinea(self):
            return self.getTypedRuleContext(RiscVParser.FinlineaContext,0)


        def ETIQUETA(self):
            return self.getToken(RiscVParser.ETIQUETA, 0)

        def declaracion(self):
            return self.getTypedRuleContext(RiscVParser.DeclaracionContext,0)


        def getRuleIndex(self):
            return RiscVParser.RULE_lineadatos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLineadatos" ):
                listener.enterLineadatos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLineadatos" ):
                listener.exitLineadatos(self)




    def lineadatos(self):

        localctx = RiscVParser.LineadatosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_lineadatos)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 48
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RiscVParser.ETIQUETA:
                self.state = 47
                localctx._ETIQUETA = self.match(RiscVParser.ETIQUETA)


            InfoCompil.Program.addTag(localctx._ETIQUETA, "variable");
            self.state = 52
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 121)) & ~0x3f) == 0 and ((1 << (_la - 121)) & ((1 << (RiscVParser.T_WORD - 121)) | (1 << (RiscVParser.T_HALF - 121)) | (1 << (RiscVParser.T_BYTE - 121)) | (1 << (RiscVParser.T_FLOAT - 121)) | (1 << (RiscVParser.T_DOUBLE - 121)) | (1 << (RiscVParser.T_ASCII - 121)) | (1 << (RiscVParser.T_ASCIIZ - 121)) | (1 << (RiscVParser.T_SPACE - 121)))) != 0):
                self.state = 51
                self.declaracion()


            self.state = 54
            self.finlinea()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclaracionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tamRes = None # Token
            self.var_int = None # Token
            self._NUMERO_INT = None # Token
            self.vi = list() # of Tokens
            self.var_fp = None # Token
            self._NUMERO_FP = None # Token
            self.vf = list() # of Tokens
            self.var_string = None # Token
            self._CADENA = None # Token
            self.vs = list() # of Tokens

        def T_SPACE(self):
            return self.getToken(RiscVParser.T_SPACE, 0)

        def NUMERO_INT(self, i:int=None):
            if i is None:
                return self.getTokens(RiscVParser.NUMERO_INT)
            else:
                return self.getToken(RiscVParser.NUMERO_INT, i)

        def T_WORD(self):
            return self.getToken(RiscVParser.T_WORD, 0)

        def T_HALF(self):
            return self.getToken(RiscVParser.T_HALF, 0)

        def T_BYTE(self):
            return self.getToken(RiscVParser.T_BYTE, 0)

        def COMA(self, i:int=None):
            if i is None:
                return self.getTokens(RiscVParser.COMA)
            else:
                return self.getToken(RiscVParser.COMA, i)

        def NUMERO_FP(self, i:int=None):
            if i is None:
                return self.getTokens(RiscVParser.NUMERO_FP)
            else:
                return self.getToken(RiscVParser.NUMERO_FP, i)

        def T_FLOAT(self):
            return self.getToken(RiscVParser.T_FLOAT, 0)

        def T_DOUBLE(self):
            return self.getToken(RiscVParser.T_DOUBLE, 0)

        def CADENA(self, i:int=None):
            if i is None:
                return self.getTokens(RiscVParser.CADENA)
            else:
                return self.getToken(RiscVParser.CADENA, i)

        def T_ASCII(self):
            return self.getToken(RiscVParser.T_ASCII, 0)

        def T_ASCIIZ(self):
            return self.getToken(RiscVParser.T_ASCIIZ, 0)

        def getRuleIndex(self):
            return RiscVParser.RULE_declaracion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaracion" ):
                listener.enterDeclaracion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaracion" ):
                listener.exitDeclaracion(self)




    def declaracion(self):

        localctx = RiscVParser.DeclaracionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_declaracion)
        self._la = 0 # Token type
        try:
            self.state = 88
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RiscVParser.T_SPACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 56
                self.match(RiscVParser.T_SPACE)
                self.state = 57
                localctx.tamRes = self.match(RiscVParser.NUMERO_INT)
                pass
            elif token in [RiscVParser.T_WORD, RiscVParser.T_HALF, RiscVParser.T_BYTE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 58
                localctx.var_int = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 121)) & ~0x3f) == 0 and ((1 << (_la - 121)) & ((1 << (RiscVParser.T_WORD - 121)) | (1 << (RiscVParser.T_HALF - 121)) | (1 << (RiscVParser.T_BYTE - 121)))) != 0)):
                    localctx.var_int = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 59
                localctx._NUMERO_INT = self.match(RiscVParser.NUMERO_INT)
                localctx.vi.append(localctx._NUMERO_INT)
                self.state = 64
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==RiscVParser.COMA:
                    self.state = 60
                    self.match(RiscVParser.COMA)
                    self.state = 61
                    localctx._NUMERO_INT = self.match(RiscVParser.NUMERO_INT)
                    localctx.vi.append(localctx._NUMERO_INT)
                    self.state = 66
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                InfoCompil.Tags.AddVariables(localctx.var_int, localctx.vi);    
                pass
            elif token in [RiscVParser.T_FLOAT, RiscVParser.T_DOUBLE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 68
                localctx.var_fp = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==RiscVParser.T_FLOAT or _la==RiscVParser.T_DOUBLE):
                    localctx.var_fp = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 69
                localctx._NUMERO_FP = self.match(RiscVParser.NUMERO_FP)
                localctx.vf.append(localctx._NUMERO_FP)
                self.state = 74
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==RiscVParser.COMA:
                    self.state = 70
                    self.match(RiscVParser.COMA)
                    self.state = 71
                    localctx._NUMERO_FP = self.match(RiscVParser.NUMERO_FP)
                    localctx.vf.append(localctx._NUMERO_FP)
                    self.state = 76
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                InfoCompil.Tags.AddVariables(localctx.var_fp, localctx.vf);     
                pass
            elif token in [RiscVParser.T_ASCII, RiscVParser.T_ASCIIZ]:
                self.enterOuterAlt(localctx, 4)
                self.state = 78
                localctx.var_string = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==RiscVParser.T_ASCII or _la==RiscVParser.T_ASCIIZ):
                    localctx.var_string = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 79
                localctx._CADENA = self.match(RiscVParser.CADENA)
                localctx.vs.append(localctx._CADENA)
                self.state = 84
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==RiscVParser.COMA:
                    self.state = 80
                    self.match(RiscVParser.COMA)
                    self.state = 81
                    localctx._CADENA = self.match(RiscVParser.CADENA)
                    localctx.vf.append(localctx._CADENA)
                    self.state = 86
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                InfoCompil.Tags.AddVariables(localctx.var_string, localctx.vs); 
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BloquecodigoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ZONACODIGO(self):
            return self.getToken(RiscVParser.ZONACODIGO, 0)

        def finlinea(self):
            return self.getTypedRuleContext(RiscVParser.FinlineaContext,0)


        def lineacodigo(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RiscVParser.LineacodigoContext)
            else:
                return self.getTypedRuleContext(RiscVParser.LineacodigoContext,i)


        def getRuleIndex(self):
            return RiscVParser.RULE_bloquecodigo

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBloquecodigo" ):
                listener.enterBloquecodigo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBloquecodigo" ):
                listener.exitBloquecodigo(self)




    def bloquecodigo(self):

        localctx = RiscVParser.BloquecodigoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_bloquecodigo)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 90
            self.match(RiscVParser.ZONACODIGO)
            self.state = 91
            self.finlinea()
            self.state = 95
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (RiscVParser.LUI - 51)) | (1 << (RiscVParser.AUIPC - 51)) | (1 << (RiscVParser.JAL - 51)) | (1 << (RiscVParser.JALR - 51)) | (1 << (RiscVParser.BEQ - 51)) | (1 << (RiscVParser.BNE - 51)) | (1 << (RiscVParser.BLT - 51)) | (1 << (RiscVParser.BGE - 51)) | (1 << (RiscVParser.BLTU - 51)) | (1 << (RiscVParser.BGEU - 51)) | (1 << (RiscVParser.LB - 51)) | (1 << (RiscVParser.LH - 51)) | (1 << (RiscVParser.LW - 51)) | (1 << (RiscVParser.LBU - 51)) | (1 << (RiscVParser.LHU - 51)) | (1 << (RiscVParser.SB - 51)) | (1 << (RiscVParser.SH - 51)) | (1 << (RiscVParser.SW - 51)) | (1 << (RiscVParser.ADDI - 51)) | (1 << (RiscVParser.SLTI - 51)) | (1 << (RiscVParser.SLTIU - 51)) | (1 << (RiscVParser.XORI - 51)) | (1 << (RiscVParser.ORI - 51)) | (1 << (RiscVParser.ANDI - 51)) | (1 << (RiscVParser.SLLI - 51)) | (1 << (RiscVParser.SRLI - 51)) | (1 << (RiscVParser.SRAI - 51)) | (1 << (RiscVParser.ADD - 51)) | (1 << (RiscVParser.SUB - 51)) | (1 << (RiscVParser.SLL - 51)) | (1 << (RiscVParser.SLT - 51)) | (1 << (RiscVParser.SLTU - 51)) | (1 << (RiscVParser.XOR - 51)) | (1 << (RiscVParser.SRL - 51)) | (1 << (RiscVParser.SRA - 51)) | (1 << (RiscVParser.OR - 51)) | (1 << (RiscVParser.AND - 51)) | (1 << (RiscVParser.ECALL - 51)) | (1 << (RiscVParser.EBREAK - 51)) | (1 << (RiscVParser.MUL - 51)) | (1 << (RiscVParser.MULH - 51)) | (1 << (RiscVParser.MULHSU - 51)) | (1 << (RiscVParser.MULHU - 51)) | (1 << (RiscVParser.DIV - 51)) | (1 << (RiscVParser.DIVU - 51)) | (1 << (RiscVParser.REM - 51)) | (1 << (RiscVParser.REMU - 51)))) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & ((1 << (RiscVParser.COMENTARIO - 130)) | (1 << (RiscVParser.NUEVALINEA - 130)) | (1 << (RiscVParser.ETIQUETA - 130)))) != 0):
                self.state = 92
                self.lineacodigo()
                self.state = 97
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineacodigoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._ETIQUETA = None # Token

        def finlinea(self):
            return self.getTypedRuleContext(RiscVParser.FinlineaContext,0)


        def ETIQUETA(self):
            return self.getToken(RiscVParser.ETIQUETA, 0)

        def instruccion(self):
            return self.getTypedRuleContext(RiscVParser.InstruccionContext,0)


        def getRuleIndex(self):
            return RiscVParser.RULE_lineacodigo

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLineacodigo" ):
                listener.enterLineacodigo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLineacodigo" ):
                listener.exitLineacodigo(self)




    def lineacodigo(self):

        localctx = RiscVParser.LineacodigoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_lineacodigo)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RiscVParser.ETIQUETA:
                self.state = 98
                localctx._ETIQUETA = self.match(RiscVParser.ETIQUETA)


            InfoCompil.Tags.Add(localctx._ETIQUETA, "code");
            self.state = 103
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & ((1 << (RiscVParser.LUI - 51)) | (1 << (RiscVParser.AUIPC - 51)) | (1 << (RiscVParser.JAL - 51)) | (1 << (RiscVParser.JALR - 51)) | (1 << (RiscVParser.BEQ - 51)) | (1 << (RiscVParser.BNE - 51)) | (1 << (RiscVParser.BLT - 51)) | (1 << (RiscVParser.BGE - 51)) | (1 << (RiscVParser.BLTU - 51)) | (1 << (RiscVParser.BGEU - 51)) | (1 << (RiscVParser.LB - 51)) | (1 << (RiscVParser.LH - 51)) | (1 << (RiscVParser.LW - 51)) | (1 << (RiscVParser.LBU - 51)) | (1 << (RiscVParser.LHU - 51)) | (1 << (RiscVParser.SB - 51)) | (1 << (RiscVParser.SH - 51)) | (1 << (RiscVParser.SW - 51)) | (1 << (RiscVParser.ADDI - 51)) | (1 << (RiscVParser.SLTI - 51)) | (1 << (RiscVParser.SLTIU - 51)) | (1 << (RiscVParser.XORI - 51)) | (1 << (RiscVParser.ORI - 51)) | (1 << (RiscVParser.ANDI - 51)) | (1 << (RiscVParser.SLLI - 51)) | (1 << (RiscVParser.SRLI - 51)) | (1 << (RiscVParser.SRAI - 51)) | (1 << (RiscVParser.ADD - 51)) | (1 << (RiscVParser.SUB - 51)) | (1 << (RiscVParser.SLL - 51)) | (1 << (RiscVParser.SLT - 51)) | (1 << (RiscVParser.SLTU - 51)) | (1 << (RiscVParser.XOR - 51)) | (1 << (RiscVParser.SRL - 51)) | (1 << (RiscVParser.SRA - 51)) | (1 << (RiscVParser.OR - 51)) | (1 << (RiscVParser.AND - 51)) | (1 << (RiscVParser.ECALL - 51)) | (1 << (RiscVParser.EBREAK - 51)) | (1 << (RiscVParser.MUL - 51)) | (1 << (RiscVParser.MULH - 51)) | (1 << (RiscVParser.MULHSU - 51)) | (1 << (RiscVParser.MULHU - 51)) | (1 << (RiscVParser.DIV - 51)) | (1 << (RiscVParser.DIVU - 51)) | (1 << (RiscVParser.REM - 51)) | (1 << (RiscVParser.REMU - 51)))) != 0):
                self.state = 102
                self.instruccion()


            self.state = 105
            self.finlinea()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reg_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REG_INT(self):
            return self.getToken(RiscVParser.REG_INT, 0)

        def REG_INT_NAME(self):
            return self.getToken(RiscVParser.REG_INT_NAME, 0)

        def getRuleIndex(self):
            return RiscVParser.RULE_reg_int

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReg_int" ):
                listener.enterReg_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReg_int" ):
                listener.exitReg_int(self)




    def reg_int(self):

        localctx = RiscVParser.Reg_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_reg_int)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            _la = self._input.LA(1)
            if not(_la==RiscVParser.REG_INT or _la==RiscVParser.REG_INT_NAME):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Inm_intContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERO_INT(self):
            return self.getToken(RiscVParser.NUMERO_INT, 0)

        def getRuleIndex(self):
            return RiscVParser.RULE_inm_int

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInm_int" ):
                listener.enterInm_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInm_int" ):
                listener.exitInm_int(self)




    def inm_int(self):

        localctx = RiscVParser.Inm_intContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_inm_int)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self.match(RiscVParser.NUMERO_INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParEtiqContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(RiscVParser.IDENT, 0)

        def getRuleIndex(self):
            return RiscVParser.RULE_parEtiq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParEtiq" ):
                listener.enterParEtiq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParEtiq" ):
                listener.exitParEtiq(self)




    def parEtiq(self):

        localctx = RiscVParser.ParEtiqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_parEtiq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.match(RiscVParser.IDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstruccionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.op = None # Token
            self.r1 = None # Reg_intContext
            self.r2 = None # Reg_intContext
            self.r3 = None # Reg_intContext
            self.inm = None # Inm_intContext
            self.rs = None # Reg_intContext

        def COMA(self, i:int=None):
            if i is None:
                return self.getTokens(RiscVParser.COMA)
            else:
                return self.getToken(RiscVParser.COMA, i)

        def reg_int(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RiscVParser.Reg_intContext)
            else:
                return self.getTypedRuleContext(RiscVParser.Reg_intContext,i)


        def SLL(self):
            return self.getToken(RiscVParser.SLL, 0)

        def SRL(self):
            return self.getToken(RiscVParser.SRL, 0)

        def SRA(self):
            return self.getToken(RiscVParser.SRA, 0)

        def ADD(self):
            return self.getToken(RiscVParser.ADD, 0)

        def SUB(self):
            return self.getToken(RiscVParser.SUB, 0)

        def XOR(self):
            return self.getToken(RiscVParser.XOR, 0)

        def OR(self):
            return self.getToken(RiscVParser.OR, 0)

        def AND(self):
            return self.getToken(RiscVParser.AND, 0)

        def SLT(self):
            return self.getToken(RiscVParser.SLT, 0)

        def SLTU(self):
            return self.getToken(RiscVParser.SLTU, 0)

        def MUL(self):
            return self.getToken(RiscVParser.MUL, 0)

        def MULH(self):
            return self.getToken(RiscVParser.MULH, 0)

        def MULHSU(self):
            return self.getToken(RiscVParser.MULHSU, 0)

        def MULHU(self):
            return self.getToken(RiscVParser.MULHU, 0)

        def DIV(self):
            return self.getToken(RiscVParser.DIV, 0)

        def DIVU(self):
            return self.getToken(RiscVParser.DIVU, 0)

        def REM(self):
            return self.getToken(RiscVParser.REM, 0)

        def REMU(self):
            return self.getToken(RiscVParser.REMU, 0)

        def inm_int(self):
            return self.getTypedRuleContext(RiscVParser.Inm_intContext,0)


        def ADDI(self):
            return self.getToken(RiscVParser.ADDI, 0)

        def ANDI(self):
            return self.getToken(RiscVParser.ANDI, 0)

        def ORI(self):
            return self.getToken(RiscVParser.ORI, 0)

        def XORI(self):
            return self.getToken(RiscVParser.XORI, 0)

        def SLTI(self):
            return self.getToken(RiscVParser.SLTI, 0)

        def SLTIU(self):
            return self.getToken(RiscVParser.SLTIU, 0)

        def SLLI(self):
            return self.getToken(RiscVParser.SLLI, 0)

        def SRLI(self):
            return self.getToken(RiscVParser.SRLI, 0)

        def SRAI(self):
            return self.getToken(RiscVParser.SRAI, 0)

        def LPAREN(self):
            return self.getToken(RiscVParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(RiscVParser.RPAREN, 0)

        def LB(self):
            return self.getToken(RiscVParser.LB, 0)

        def LBU(self):
            return self.getToken(RiscVParser.LBU, 0)

        def LH(self):
            return self.getToken(RiscVParser.LH, 0)

        def LHU(self):
            return self.getToken(RiscVParser.LHU, 0)

        def LW(self):
            return self.getToken(RiscVParser.LW, 0)

        def SB(self):
            return self.getToken(RiscVParser.SB, 0)

        def SH(self):
            return self.getToken(RiscVParser.SH, 0)

        def SW(self):
            return self.getToken(RiscVParser.SW, 0)

        def LUI(self):
            return self.getToken(RiscVParser.LUI, 0)

        def AUIPC(self):
            return self.getToken(RiscVParser.AUIPC, 0)

        def ECALL(self):
            return self.getToken(RiscVParser.ECALL, 0)

        def EBREAK(self):
            return self.getToken(RiscVParser.EBREAK, 0)

        def BEQ(self):
            return self.getToken(RiscVParser.BEQ, 0)

        def BNE(self):
            return self.getToken(RiscVParser.BNE, 0)

        def BLT(self):
            return self.getToken(RiscVParser.BLT, 0)

        def BLTU(self):
            return self.getToken(RiscVParser.BLTU, 0)

        def BGE(self):
            return self.getToken(RiscVParser.BGE, 0)

        def BGEU(self):
            return self.getToken(RiscVParser.BGEU, 0)

        def JAL(self):
            return self.getToken(RiscVParser.JAL, 0)

        def JALR(self):
            return self.getToken(RiscVParser.JALR, 0)

        def getRuleIndex(self):
            return RiscVParser.RULE_instruccion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstruccion" ):
                listener.enterInstruccion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstruccion" ):
                listener.exitInstruccion(self)




    def instruccion(self):

        localctx = RiscVParser.InstruccionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_instruccion)
        self._la = 0 # Token type
        try:
            self.state = 194
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 113
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 78)) & ~0x3f) == 0 and ((1 << (_la - 78)) & ((1 << (RiscVParser.ADD - 78)) | (1 << (RiscVParser.SUB - 78)) | (1 << (RiscVParser.SLL - 78)) | (1 << (RiscVParser.SLT - 78)) | (1 << (RiscVParser.SLTU - 78)) | (1 << (RiscVParser.XOR - 78)) | (1 << (RiscVParser.SRL - 78)) | (1 << (RiscVParser.SRA - 78)) | (1 << (RiscVParser.OR - 78)) | (1 << (RiscVParser.AND - 78)) | (1 << (RiscVParser.MUL - 78)) | (1 << (RiscVParser.MULH - 78)) | (1 << (RiscVParser.MULHSU - 78)) | (1 << (RiscVParser.MULHU - 78)) | (1 << (RiscVParser.DIV - 78)) | (1 << (RiscVParser.DIVU - 78)) | (1 << (RiscVParser.REM - 78)) | (1 << (RiscVParser.REMU - 78)))) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 114
                localctx.r1 = self.reg_int()
                self.state = 115
                self.match(RiscVParser.COMA)
                self.state = 116
                localctx.r2 = self.reg_int()
                self.state = 117
                self.match(RiscVParser.COMA)
                self.state = 118
                localctx.r3 = self.reg_int()
                 InfoCompil.Instruction.addInstI1(localctx.op,r1, r2, r3);
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 121
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 69)) & ~0x3f) == 0 and ((1 << (_la - 69)) & ((1 << (RiscVParser.ADDI - 69)) | (1 << (RiscVParser.SLTI - 69)) | (1 << (RiscVParser.SLTIU - 69)) | (1 << (RiscVParser.XORI - 69)) | (1 << (RiscVParser.ORI - 69)) | (1 << (RiscVParser.ANDI - 69)))) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 122
                localctx.r1 = self.reg_int()
                self.state = 123
                self.match(RiscVParser.COMA)
                self.state = 124
                localctx.r2 = self.reg_int()
                self.state = 125
                self.match(RiscVParser.COMA)
                self.state = 126
                localctx.inm = self.inm_int()
                 InfoCompil.Instructions.addInstI2(localctx.op,r1,r2,inm);
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 129
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 75)) & ~0x3f) == 0 and ((1 << (_la - 75)) & ((1 << (RiscVParser.SLLI - 75)) | (1 << (RiscVParser.SRLI - 75)) | (1 << (RiscVParser.SRAI - 75)))) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 130
                localctx.r1 = self.reg_int()
                self.state = 131
                self.match(RiscVParser.COMA)
                self.state = 132
                localctx.r2 = self.reg_int()
                self.state = 133
                self.match(RiscVParser.COMA)
                self.state = 134
                localctx.inm = self.inm_int()
                 InfoCompil.Instructions.addInstI3(localctx.op,r1,r2,inm);
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 137
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 61)) & ~0x3f) == 0 and ((1 << (_la - 61)) & ((1 << (RiscVParser.LB - 61)) | (1 << (RiscVParser.LH - 61)) | (1 << (RiscVParser.LW - 61)) | (1 << (RiscVParser.LBU - 61)) | (1 << (RiscVParser.LHU - 61)))) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 138
                localctx.r1 = self.reg_int()
                self.state = 139
                self.match(RiscVParser.COMA)
                self.state = 140
                localctx.inm = self.inm_int()
                self.state = 141
                self.match(RiscVParser.LPAREN)
                self.state = 142
                localctx.rs = self.reg_int()
                self.state = 143
                self.match(RiscVParser.RPAREN)
                 InfoCompil.Instructions.addInstI4(localctx.op,r1,inm,rs);
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 146
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (RiscVParser.SB - 66)) | (1 << (RiscVParser.SH - 66)) | (1 << (RiscVParser.SW - 66)))) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 147
                localctx.r1 = self.reg_int()
                self.state = 148
                self.match(RiscVParser.COMA)
                self.state = 149
                localctx.inm = self.inm_int()
                self.state = 150
                self.match(RiscVParser.LPAREN)
                self.state = 151
                localctx.rs = self.reg_int()
                self.state = 152
                self.match(RiscVParser.RPAREN)
                 InfoCompil.Instructions.addInstS1(localctx.op,r1,inm,rs);
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 155
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==RiscVParser.LUI or _la==RiscVParser.AUIPC):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 156
                localctx.r1 = self.reg_int()
                self.state = 157
                self.match(RiscVParser.COMA)
                self.state = 158
                localctx.inm = self.inm_int()
                 InfoCompil.Instructions.addInstU1(localctx.op,r1,inm);
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 161
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==RiscVParser.ECALL or _la==RiscVParser.EBREAK):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                 InfoCompil.Instructions.addInstI5(localctx.op);
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 163
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << RiscVParser.BEQ) | (1 << RiscVParser.BNE) | (1 << RiscVParser.BLT) | (1 << RiscVParser.BGE) | (1 << RiscVParser.BLTU) | (1 << RiscVParser.BGEU))) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 164
                localctx.r1 = self.reg_int()
                self.state = 165
                self.match(RiscVParser.COMA)
                self.state = 166
                localctx.r2 = self.reg_int()
                self.state = 167
                self.match(RiscVParser.COMA)
                self.state = 168
                localctx.inm = self.inm_int()
                 InfoCompil.Instructions.addInstB1(localctx.op,r1,r2,inm);
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 171
                localctx.op = self.match(RiscVParser.JAL)
                self.state = 172
                localctx.r1 = self.reg_int()
                self.state = 173
                self.match(RiscVParser.COMA)
                self.state = 174
                localctx.inm = self.inm_int()
                 InfoCompil.Instructions.addInstJ1(localctx.op,r1,inm);
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 177
                localctx.op = self.match(RiscVParser.JALR)
                self.state = 178
                localctx.r1 = self.reg_int()
                self.state = 179
                self.match(RiscVParser.COMA)
                self.state = 180
                localctx.r2 = self.reg_int()
                self.state = 181
                self.match(RiscVParser.COMA)
                self.state = 182
                localctx.inm = self.inm_int()
                 InfoCompil.Instructions.addInstI6(localctx.op,r1,r2,inm);
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 185
                localctx.op = self.match(RiscVParser.JALR)
                self.state = 186
                localctx.r1 = self.reg_int()
                self.state = 187
                self.match(RiscVParser.COMA)
                self.state = 188
                localctx.inm = self.inm_int()
                self.state = 189
                self.match(RiscVParser.LPAREN)
                self.state = 190
                localctx.rs = self.reg_int()
                self.state = 191
                self.match(RiscVParser.RPAREN)
                 InfoCompil.Instructions.addInstI7(localctx.op,r1,inm,rs);
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





